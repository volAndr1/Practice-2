# README

## Задачі та відповіді

### 1. Початкова підготовка середовища
- Клонуйте репозиторій `vite-react-boilerplate`.

```bash
git clone https://github.com/<username>/vite-react-boilerplate.git
```

- Встановіть усі залежності проєкту, використовуючи команду:

```bash
pnpm install
```

- Запустіть початковий скрипт налаштування проєкту:

```bash
pnpm run setup
```

**Відповідь:** Ці кроки допомагають налаштувати середовище для роботи з проєктом, інсталюючи всі необхідні залежності та виконуючи базову ініціалізацію проєкту.

---

### 2. Аналіз структури файлу `package.json`
#### Призначення полів:
- `name`: Визначає назву проєкту, яку використовують для ідентифікації пакета в npm.
- `author`: Інформація про автора проєкту.
- `description`: Короткий опис, що пояснює призначення проєкту.
- `version`: Версія проєкту згідно з принципами семантичного версіонування (SemVer).
- `license`: Ліцензія, під якою поширюється проєкт (наприклад, MIT).
- `repository`: Інформація про репозиторій проєкту (URL).
- `scripts`: Набір команд для автоматизації процесів, таких як запуск тестів, збірка тощо.
- `dependencies`: Залежності, необхідні для роботи програми (наприклад, бібліотеки та фреймворки).
- `devDependencies`: Залежності, що використовуються тільки під час розробки (наприклад, інструменти для тестування або транспіляції).

#### Логіка класифікації:
- `dependencies`: Пакети, необхідні для функціонування проєкту в продуктивному середовищі.
- `devDependencies`: Пакети, які використовуються тільки під час розробки та не входять до фінальної версії програми.

---

### 3. Семантичне версіонування (SemVer)
#### Ознайомлення з принципами SemVer:
Семантичне версіонування (SemVer) використовує формат: `MAJOR.MINOR.PATCH`.
- `MAJOR` (мажорні версії): Випускаються при несумісних змінах API.
- `MINOR` (мінорні версії): Випускаються при зворотній сумісності з додаванням нових функцій.
- `PATCH` (патчі): Випускаються при виправленні помилок без зміни функціональності.

#### Дослідження версій пакетів бойлерплейту:
При оновленні версій, згідно з SemVer:
- Мажорні оновлення можуть містити зміни, що порушують сумісність з попередніми версіями.
- Мінорні оновлення додають нові можливості без порушення сумісності.
- Патчі виправляють помилки, не змінюючи функціональність.

---

### 4. Дослідження додаткових конфігураційних файлів
#### Призначення, структура та елементи:
- **`README.md`**: Документація для користувачів проєкту. Містить загальні відомості, інструкції з налаштування, використання тощо.
- **`.gitignore`**: Файл, що вказує Git, які файли і директорії ігнорувати при коміті (наприклад, файли логів або залежності).
- **`LICENSE`**: Файл з ліцензією, що визначає умови використання коду проєкту.

---

### 5. Аналіз роботи гіт-хуків Husky
#### Артефакти Husky:
Husky дозволяє автоматизувати виконання скриптів до або після певних дій з Git, таких як commit, push тощо. Після налаштування Husky створюються такі файли:
- `.husky/pre-commit`: Скрипт, що виконується перед комітом (наприклад, перевірка коду на помилки).
- `.husky/commit-msg`: Скрипт, що виконується для перевірки повідомлення коміту.

#### Призначення та роль:
- **Pre-commit hooks** використовуються для автоматичних перевірок перед комітом, що дозволяє уникнути помилок у коді.
- **Commit-msg hook** гарантує, що повідомлення коміту відповідають заданим вимогам (наприклад, формат).

---

### 6. Використання змінних оточення
#### Створення скрипта:
Створіть скрипт `readEnvVar.js`, який буде читати змінну оточення і виводити її значення:

```javascript
console.log(process.env.MY_ENV_VAR);
```

#### Задавання змінних оточення:
- На рівні ОС:

```bash
export MY_ENV_VAR="value_from_os"
```

- На рівні сесії терміналу:

```bash
MY_ENV_VAR="value_from_session" node readEnvVar.js
```

- На рівні `.env` файлу:
Створіть файл `.env` в кореневій директорії проєкту та додайте змінну:

```env
MY_ENV_VAR=value_from_dotenv
```

#### Пріоритетність:
- Змінні оточення з файлу `.env` мають найнижчий пріоритет.
- Змінні, задані в терміналі, мають більший пріоритет.
- Змінні на рівні ОС мають найвищий пріоритет.

Результати показують, що значення змінних оточення застосовуються в порядку їх визначення, з найвищим пріоритетом для змінних, встановлених на рівні ОС.

---

Цей README містить всю необхідну інформацію для розуміння виконаних завдань та відповідей на кожне з них.
